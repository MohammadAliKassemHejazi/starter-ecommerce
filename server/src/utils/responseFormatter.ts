import { Response } from 'express';

export interface ApiResponse {
  success: boolean;
  message: string;
  data?: any;
  // errors are strictly optional and top-level only if generated by error handlers that bypass middleware logic,
  // but typically our middleware will move them into data if they exist as 'rest'.
  // However, for type safety in controllers, we keep it here or remove it if we want to enforce data-only.
  // The user wants EVERYTHING under data.
  // But standard error responses (success: false) often keep errors top level.
  // The middleware only moves "rest" into data.
  // If success=false, and errors is passed, it becomes rest -> data.errors.
  errors?: any[];
}

export class ResponseFormatter {
  static success(res: Response, data: any = null, message: string = 'Success', statusCode: number = 200, meta?: any): Response {
    let finalData = data;

    // If meta is provided, merge it into data
    if (meta) {
      if (finalData === null || finalData === undefined) {
        finalData = meta;
      } else if (Array.isArray(finalData)) {
        // If data is an array and we have meta, wrap it
        // STANDARDIZED: Using 'items' consistently
        finalData = {
          items: finalData,
          ...meta,
        };
      } else if (typeof finalData === 'object') {
        finalData = {
          ...finalData,
          ...meta,
        };
      }
    }

    const response: ApiResponse = {
      success: true,
      message,
      data: finalData,
    };

    return res.status(statusCode).json(response);
  }

  static error(res: Response, message: string = 'An error occurred', statusCode: number = 500, errors?: any[]): Response {
    const response: ApiResponse = {
      success: false,
      message,
      errors,
    };

    return res.status(statusCode).json(response);
  }

  static validationError(res: Response, errors: any[], message: string = 'Validation failed'): Response {
    return this.error(res, message, 400, errors);
  }

  static notFound(res: Response, message: string = 'Resource not found'): Response {
    return this.error(res, message, 404);
  }

  static unauthorized(res: Response, message: string = 'Unauthorized access'): Response {
    return this.error(res, message, 401);
  }

  static forbidden(res: Response, message: string = 'Access forbidden'): Response {
    return this.error(res, message, 403);
  }

  static paginated(res: Response, data: any[], page: number, limit: number, total: number, message: string = 'Success'): Response {
    const totalPages = Math.ceil(total / limit);

    // We structure the data to contain both the list and pagination info
    const responseData = {
      // STANDARDIZED: Using 'items' consistently
      items: data,
      page,
      limit,
      total,
      totalPages,
    };

    return this.success(res, responseData, message, 200);
  }
}
